# 基本知识点
## 1. 面向过程编程
1. 视角聚焦于解决问题的步骤, 特点是每一步的行为都基本固定, 且非常依赖上下文. 一旦编码完毕, 程序内各步骤就形成一个强相关的整体, 不方便频繁的修改和拓展

2. 这种编码形式在编码前会明确解决问题的各个步骤并分解至最简单的语句, 故编码比较简单

3. 面向过程的程序代码一般适用于不会经常变动代码内容的场景, 或者是在程序中的某一部分使用面向过程编码, 这样即使发生了需求变动, 也只需要重写一部分较少的代码

- 面向过程编程标签
    - 简单
    - 固定
    - 依赖上下文(耦合强)
    - 重写
    - 适合小场景

## 2. 面向对象编程
1. 站在上帝视角, 对全局设计和建模

2. 上帝创造出程序中的对象, 不同对象有着独特的属性, 特征, 功能, 对象之间相互作用一起支撑程序的运行

3. 因为程序的运行完全依赖对象的交互, 所以上帝也无法明确程序的每一个步骤

4. 面向对象编程的代码一般适用于经常变动代码内容的场景, 通过此种编程方式产出的代码, 模块只不会有很强的耦合性, 这就提供了可以灵活更换、修改、拓展模块的能力。

- 面向对象编程标签
    - 复杂
    - 灵活
    - 模块化（低耦合）
    - 可插拔
    - 适合大规模

## 注意
>1. 面向过程和面向对象只是对一个程序的设计视角和模式不同，两者各有各的优缺点

>2. 我觉得良好的程序设计应该是根据场景使用合适的编程模式, 一个优秀的程序应该支持混合编程, 在程序的不同阶段, 不同角度, 不同抽象层次使用对应的最适合的编程模式, 各种编程模式相辅相成协作完成程序的正确运行.

---

# 二. 类的结构

## 1. 类的理解
1. 不论是程序世界还是现实世界, 类都是一个有着相似特征, 属性, 功能的对象集合体的描述

2. 一般我们以特征和功能来描述一个对象, 如:
我们描述一个人, 会说这个人有鼻子眼睛耳朵...,同时他还可以吃饭睡觉打豆豆...

3. 对象的长相,或者说特征(或者说可以被看到的属性)是对象的描述之一

4. 对象的能力,功能,行为(对象可以做的事情)是对象的描述之二

5. 而多个相同对象应该有着相同或者相似的特征和功能, 这些相似的特征和功能就是这类对象的描述

6. 而反过来说, 如果知道一类对象的描述, 那么上帝完全可以通过这些描述信息, 创建一个属于此类的对象

> **多个对象---->一个类别描述, 这叫抽象**

> **一个类别描述---->多个或者一个对象, 这叫实例化**

## 2.代码形式
```python
class Student(object, metaclass=type):
    count = 0
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def show_name(self):
        print('my name is: ', sellf.name)
```
类代码可以**暂时**的理解成有如下几个部分
- 1. `class`关键字(必须)
- 2. 类名`Student`(必须)
- 3. 继承类列表`object`(可不写)
- 4. 元类指定`metaclass`(可不写)
- 5. 类体(必须有, 但可以是`pass`)
    - 以下为类体中可以包含的内容:
    - 1. 类数据属性(可不写)
    - 2. 构造函数(可不写)
    - 3. 普通对象绑定方法`show_name`, 也叫实例方法(可不写)

所以一个**最最简单**的类代码就像这样:
```python
class Student:
    pass
```

## 3. 类和函数的一些区别
函数

1. `python`解释器在**编译代码** 的时候会在命名空间申明类引用和类对象的创建, **会执行类体代码**, 并创建此类的命名空间, 命名空间作为类对象的`__dict__`属性值

2. 如果类中的代码是函数定义或者其他变量定义, 则执行声明定义, 如果代码是执行语句(如`print`)则执行此语句

3. **当类被执行时**, 如`Student()`, 类**不会执行类体代码**, 而是返回此类的一个**实例化对象**, 返回对象的过程叫做实例化

## 4. 类中的数据
对象的属性保存在对象的`__dict__`字典中, 可以通过对象.属性名 的方式来访问和修改

类也是一个对象, 类在定义时, 类体中定义的数据即为类对象的属性, 可以通过 类名.数据名 的方式来访问和修改, 如
```python
class Student():
    count = 10

print(Student.count) # 10

Student.count = 20

print(Student.count) # 20

del Student.count

print(Student.count) # AttributeError: type object 'Student' has no attribute 'count'
```

## 5. 类中的方法(基础)
类中的方法就是一个普通的函数定义, 此函数属性也保存在`__dict__`字典中, 和数据属性一样, 可以通过 类名.函数名 的方式来访问和修改, 如
```python
def say(something):
    print('全局的say方法, hi')

class Student:
    a = 2

    def say(self):
        print('类里面的say方法, hello')

Student.say('something')  # '类里面的say方法, hello

# 类中函数属性可以重新赋值
Student.say = say
Student.say('something') # 全局的say方法, hi

del Student.say
Student.say('something') # # AttributeError: type object 'Student' has no attribute 'say'
```

**注意:**
**1. 类中定义的任何函数(默认情况下)都必须固定第一个`self`参数的存在,  所以如果是以类为主体使用类中的函数时, 就必须给self参数传递一个值, 不论这个值是什么**
**2. 类可以当做一个容器对象来保存数据**

----

# 3. 类的实例化
类的另一个非常重要的作用是: 实例化对象
```python
class Student(object):
    school = '北京大学'
    
    def __init__(self, name, age):
        self.name = name
        self.age = age

stu1 = Student('stu1', 26)
stu2 = Student('stu2', 26)

print(stu1) # <__main__.Student object at 0x00000203080930F0>
print(stu2) # <__main__.Student object at 0x0000020308093080>
print(stu1.school) # 北京大学
print(stu2.school) # 北京大学
print(stu1.name) # 'stu1'
print(stu2.name) # 'stu2'
```

> 1. 类可以被执行, 执行时传入的参数与`__init__`函数参数相对应(不用传self)
> 2. 类的执行结果是一个对象, 有内存地址
> 3. 类执行时参入参数的目的是为了初始化这个实例对象的某些属性值(当然也可以不初始化, 在后续配置)
> 4. 类中的数据属性, 被所有此类对象共享 `北京大学`
> 5. 类中的函数属性, 默认是绑定到对象的, 即每个对象都有一个绑定方法, 此方法的执行代码指向类中的此函数
> 6. 每一个对象都有自己的属性值, 通过 对象.属性名 来访问和修改
> 7. 类实例化的目的是为了得到一个对象, 程序中有了对象之后就可以相互交互, 完成程序的执行

对象使用绑定方法
> 1. 对象在创建时, `python`会将类中的普通方法做一些处理, 然后绑定到对象身上

> 2. 对象在使用这些绑定方法时, 会自动的讲对象本身传入到此方法的第一个self参数中, 这样就可以在函数中引用到此对象

> 3. 绑定方法是将函数和对象绑定在一起, 只要绑定方法被调用, 就会自动传入绑定的对象

---

# 四. 类的继承

## 1. MRO
```python
class Animal(object):
    pass

class Human(Animal):
    pass

class Student(Human):
    pass

print(Student.mro())
print(Student.__mro__)  # 二者等价，唯一的区别是上面结果是列表，下面是元组

# 返回结果
# [<class '__main__.Student'>, <class '__main__.Human'>, <class '__main__.Animal'>, <class 'object'>]
# (<class '__main__.Student'>, <class '__main__.Human'>, <class '__main__.Animal'>, <class 'object'>)
```
> 1. 类可以继承, 如果我们把多个类的相同之处再提取出来, 就可以再次抽象出一个类, 此类作为所有子类的父类

> 2. 继承类似家族数, 学科专业目录, 动物类别, 最顶层的是最抽象的类别, 越往下走, 类别越清晰, 继承树的末端就是各个具体的对象

> 3. 我们可以使用`MRO`来表示一个类他向上方向的父类路径, MRO是一个通过算法计算得到的父类元组

> 4. 任何一个类的MRO都可以表示他在继承树中的位置

MRO的作用

**MRO可以确定搜索路径**

子类一旦继承父类, 就会自动继承父类所有的代码定义(实际并没有直接得到, 而是通过MRO搜索得到)

继承的好处是不需要重复编写和父类相同的代码, 同时继承也可以明确的表示出**什么是什么**的结构关系, 坏处是继承使用的越多, 这个继承数上的耦合性就越强, 因为一旦顶层发生了变动, 下方所有子类都会受到影响